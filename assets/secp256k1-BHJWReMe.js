const mt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function ve(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function an(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Kt(t,...e){if(!an(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function oo(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ve(t.outputLen),ve(t.blockLen)}function Ae(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function un(t,e){Kt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ln(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}const dn=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),hn=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),$t=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),G=(t,e)=>t<<32-e|t>>>e,gn=(t,e)=>t<<e|t>>>32-e>>>0,Re=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,he=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255,wn=Re?t=>t:t=>he(t);function bn(t){for(let e=0;e<t.length;e++)t[e]=he(t[e])}const yn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function pn(t){Kt(t);let e="";for(let n=0;n<t.length;n++)e+=yn[t[n]];return e}const F={_0:48,_9:57,A:65,F:70,a:97,f:102};function Se(t){if(t>=F._0&&t<=F._9)return t-F._0;if(t>=F.A&&t<=F.F)return t-(F.A-10);if(t>=F.a&&t<=F.f)return t-(F.a-10)}function mn(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const i=Se(t.charCodeAt(s)),f=Se(t.charCodeAt(s+1));if(i===void 0||f===void 0){const c=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}r[o]=i*16+f}return r}const Ve=async()=>{};async function xn(t,e,n){let r=Date.now();for(let o=0;o<t;o++){n(o);const s=Date.now()-r;s>=0&&s<e||(await Ve(),r+=s)}}function $e(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function qt(t){return typeof t=="string"&&(t=$e(t)),Kt(t),t}function En(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];Kt(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}let Me=class{clone(){return this._cloneInto()}};function Bn(t,e){if(e!==void 0&&{}.toString.call(e)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(t,e)}function ge(t){const e=r=>t().update(qt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function vn(t){const e=(r,o)=>t(o).update(qt(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}function An(t){const e=(r,o)=>t(o).update(qt(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}function Sn(t=32){if(mt&&typeof mt.getRandomValues=="function")return mt.getRandomValues(new Uint8Array(t));if(mt&&typeof mt.randomBytes=="function")return mt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}const io=Object.freeze(Object.defineProperty({__proto__:null,Hash:Me,asyncLoop:xn,byteSwap:he,byteSwap32:bn,byteSwapIfBE:wn,bytesToHex:pn,checkOpts:Bn,concatBytes:En,createView:$t,hexToBytes:mn,isBytes:ln,isLE:Re,nextTick:Ve,randomBytes:Sn,rotl:gn,rotr:G,toBytes:qt,u32:hn,u8:dn,utf8ToBytes:$e,wrapConstructor:ge,wrapConstructorWithOpts:vn,wrapXOFConstructorWithOpts:An},Symbol.toStringTag,{value:"Module"})),Rt=BigInt(2**32-1),ce=BigInt(32);function ze(t,e=!1){return e?{h:Number(t&Rt),l:Number(t>>ce&Rt)}:{h:Number(t>>ce&Rt)|0,l:Number(t&Rt)|0}}function _n(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:s,l:i}=ze(t[o],e);[n[o],r[o]]=[s,i]}return[n,r]}const In=(t,e)=>BigInt(t>>>0)<<ce|BigInt(e>>>0),Ln=(t,e,n)=>t>>>n,On=(t,e,n)=>t<<32-n|e>>>n,Un=(t,e,n)=>t>>>n|e<<32-n,Hn=(t,e,n)=>t<<32-n|e>>>n,Nn=(t,e,n)=>t<<64-n|e>>>n-32,Tn=(t,e,n)=>t>>>n-32|e<<64-n,qn=(t,e)=>e,kn=(t,e)=>t,Cn=(t,e,n)=>t<<n|e>>>32-n,Rn=(t,e,n)=>e<<n|t>>>32-n,Vn=(t,e,n)=>e<<n-32|t>>>64-n,$n=(t,e,n)=>t<<n-32|e>>>64-n;function Mn(t,e,n,r){const o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:o|0}}const zn=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),Zn=(t,e,n,r)=>e+n+r+(t/2**32|0)|0,jn=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),Pn=(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0,Dn=(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0),Kn=(t,e,n,r,o,s)=>e+n+r+o+s+(t/2**32|0)|0,co={fromBig:ze,split:_n,toBig:In,shrSH:Ln,shrSL:On,rotrSH:Un,rotrSL:Hn,rotrBH:Nn,rotrBL:Tn,rotr32H:qn,rotr32L:kn,rotlSH:Cn,rotlSL:Rn,rotlBH:Vn,rotlBL:$n,add:Mn,add3L:zn,add3H:Zn,add4L:jn,add4H:Pn,add5H:Kn,add5L:Dn};function Gn(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),f=Number(n&s),c=r?4:0,a=r?0:4;t.setUint32(e+c,i,r),t.setUint32(e+a,f,r)}const Yn=(t,e,n)=>t&e^~t&n,Wn=(t,e,n)=>t&e^t&n^e&n;let Xn=class extends Me{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=$t(this.buffer)}update(e){Ae(this);const{view:n,buffer:r,blockLen:o}=this;e=qt(e);const s=e.length;for(let i=0;i<s;){const f=Math.min(o-this.pos,s-i);if(f===o){const c=$t(e);for(;o<=s-i;i+=o)this.process(c,i);continue}r.set(e.subarray(i,i+f),this.pos),this.pos+=f,i+=f,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ae(this),un(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(r,0),i=0);for(let u=i;u<o;u++)n[u]=0;Gn(r,o-8,BigInt(this.length*8),s),this.process(r,0);const f=$t(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,d=this.get();if(a>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)f.setUint32(4*u,d[u],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:f}=this;return e.length=o,e.pos=f,e.finished=s,e.destroyed=i,o%n&&e.buffer.set(r),e}};const Qn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),rt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=new Uint32Array(64);let we=class extends Xn{constructor(){super(64,32,8,!1),this.A=rt[0]|0,this.B=rt[1]|0,this.C=rt[2]|0,this.D=rt[3]|0,this.E=rt[4]|0,this.F=rt[5]|0,this.G=rt[6]|0,this.H=rt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:s,F:i,G:f,H:c}=this;return[e,n,r,o,s,i,f,c]}set(e,n,r,o,s,i,f,c){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=f|0,this.H=c|0}process(e,n){for(let u=0;u<16;u++,n+=4)ot[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const h=ot[u-15],w=ot[u-2],B=G(h,7)^G(h,18)^h>>>3,b=G(w,17)^G(w,19)^w>>>10;ot[u]=b+ot[u-7]+B+ot[u-16]|0}let{A:r,B:o,C:s,D:i,E:f,F:c,G:a,H:d}=this;for(let u=0;u<64;u++){const h=G(f,6)^G(f,11)^G(f,25),w=d+h+Yn(f,c,a)+Qn[u]+ot[u]|0,b=(G(r,2)^G(r,13)^G(r,22))+Wn(r,o,s)|0;d=a,a=c,c=f,f=i+w|0,i=s,s=o,o=r,r=w+b|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,f=f+this.E|0,c=c+this.F|0,a=a+this.G|0,d=d+this.H|0,this.set(r,o,s,i,f,c,a,d)}roundClean(){ot.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};class Jn extends we{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Fn=ge(()=>new we),tr=ge(()=>new Jn),uo=Object.freeze(Object.defineProperty({__proto__:null,SHA256:we,sha224:tr,sha256:Fn},Symbol.toStringTag,{value:"Module"}));function _e(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function er(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Gt(t,...e){if(!er(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function nr(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");_e(t.outputLen),_e(t.blockLen)}function Mt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function rr(t,e){Gt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const xt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),W=(t,e)=>t<<32-e|t>>>e;function or(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function be(t){return typeof t=="string"&&(t=or(t)),Gt(t),t}function sr(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];Gt(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}class Ze{clone(){return this._cloneInto()}}function ir(t){const e=r=>t().update(be(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function je(t=32){if(xt&&typeof xt.getRandomValues=="function")return xt.getRandomValues(new Uint8Array(t));if(xt&&typeof xt.randomBytes=="function")return xt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function cr(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),f=Number(n&s),c=r?4:0,a=r?0:4;t.setUint32(e+c,i,r),t.setUint32(e+a,f,r)}const fr=(t,e,n)=>t&e^~t&n,ar=(t,e,n)=>t&e^t&n^e&n;class ur extends Ze{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Ft(this.buffer)}update(e){Mt(this);const{view:n,buffer:r,blockLen:o}=this;e=be(e);const s=e.length;for(let i=0;i<s;){const f=Math.min(o-this.pos,s-i);if(f===o){const c=Ft(e);for(;o<=s-i;i+=o)this.process(c,i);continue}r.set(e.subarray(i,i+f),this.pos),this.pos+=f,i+=f,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Mt(this),rr(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(r,0),i=0);for(let u=i;u<o;u++)n[u]=0;cr(r,o-8,BigInt(this.length*8),s),this.process(r,0);const f=Ft(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,d=this.get();if(a>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)f.setUint32(4*u,d[u],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:f}=this;return e.length=o,e.pos=f,e.finished=s,e.destroyed=i,o%n&&e.buffer.set(r),e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yt=BigInt(0),Wt=BigInt(1),lr=BigInt(2);function wt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Q(t){if(!wt(t))throw new Error("Uint8Array expected")}function vt(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}const dr=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function At(t){Q(t);let e="";for(let n=0;n<t.length;n++)e+=dr[t[n]];return e}function Et(t){const e=t.toString(16);return e.length&1?"0"+e:e}function ye(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Yt:BigInt("0x"+t)}const tt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ie(t){if(t>=tt._0&&t<=tt._9)return t-tt._0;if(t>=tt.A&&t<=tt.F)return t-(tt.A-10);if(t>=tt.a&&t<=tt.f)return t-(tt.a-10)}function St(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const i=Ie(t.charCodeAt(s)),f=Ie(t.charCodeAt(s+1));if(i===void 0||f===void 0){const c=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}r[o]=i*16+f}return r}function X(t){return ye(At(t))}function pe(t){return Q(t),ye(At(Uint8Array.from(t).reverse()))}function ut(t,e){return St(t.toString(16).padStart(e*2,"0"))}function me(t,e){return ut(t,e).reverse()}function hr(t){return St(Et(t))}function $(t,e,n){let r;if(typeof e=="string")try{r=St(e)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(wt(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(t+" of length "+n+" expected, got "+o);return r}function P(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];Q(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}function gr(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function Xt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const te=t=>typeof t=="bigint"&&Yt<=t;function _t(t,e,n){return te(t)&&te(e)&&te(n)&&e<=t&&t<n}function at(t,e,n,r){if(!_t(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function Pe(t){let e;for(e=0;t>Yt;t>>=Wt,e+=1);return e}function wr(t,e){return t>>BigInt(e)&Wt}function br(t,e,n){return t|(n?Wt:Yt)<<BigInt(e)}const xe=t=>(lr<<BigInt(t-1))-Wt,ee=t=>new Uint8Array(t),Le=t=>Uint8Array.from(t);function De(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=ee(t),o=ee(t),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},f=(...u)=>n(o,r,...u),c=(u=ee())=>{o=f(Le([0]),u),r=f(),u.length!==0&&(o=f(Le([1]),u),r=f())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const h=[];for(;u<e;){r=f();const w=r.slice();h.push(w),u+=r.length}return P(...h)};return(u,h)=>{i(),c(u);let w;for(;!(w=h(a()));)c();return i(),w}}const yr={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||wt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function It(t,e,n={}){const r=(o,s,i)=>{const f=yr[s];if(typeof f!="function")throw new Error("invalid validator function");const c=t[o];if(!(i&&c===void 0)&&!f(c,t))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+c)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}const pr=()=>{throw new Error("not implemented")};function fe(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(o!==void 0)return o;const s=t(n,...r);return e.set(n,s),s}}const mr=Object.freeze(Object.defineProperty({__proto__:null,aInRange:at,abool:vt,abytes:Q,bitGet:wr,bitLen:Pe,bitMask:xe,bitSet:br,bytesToHex:At,bytesToNumberBE:X,bytesToNumberLE:pe,concatBytes:P,createHmacDrbg:De,ensureBytes:$,equalBytes:gr,hexToBytes:St,hexToNumber:ye,inRange:_t,isBytes:wt,memoized:fe,notImplemented:pr,numberToBytesBE:ut,numberToBytesLE:me,numberToHexUnpadded:Et,numberToVarBytesBE:hr,utf8ToBytes:Xt,validateObject:It},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const R=BigInt(0),q=BigInt(1),gt=BigInt(2),xr=BigInt(3),ae=BigInt(4),Oe=BigInt(5),Ue=BigInt(8);function C(t,e){const n=t%e;return n>=R?n:e+n}function Er(t,e,n){if(e<R)throw new Error("invalid exponent, negatives unsupported");if(n<=R)throw new Error("invalid modulus");if(n===q)return R;let r=q;for(;e>R;)e&q&&(r=r*t%n),t=t*t%n,e>>=q;return r}function D(t,e,n){let r=t;for(;e-- >R;)r*=r,r%=n;return r}function ue(t,e){if(t===R)throw new Error("invert: expected non-zero number");if(e<=R)throw new Error("invert: expected positive modulus, got "+e);let n=C(t,e),r=e,o=R,s=q;for(;n!==R;){const f=r/n,c=r%n,a=o-s*f;r=n,n=c,o=s,s=a}if(r!==q)throw new Error("invert: does not exist");return C(o,e)}function Br(t){const e=(t-q)/gt;let n,r,o;for(n=t-q,r=0;n%gt===R;n/=gt,r++);for(o=gt;o<t&&Er(o,e,t)!==t-q;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const i=(t+q)/ae;return function(c,a){const d=c.pow(a,i);if(!c.eql(c.sqr(d),a))throw new Error("Cannot find square root");return d}}const s=(n+q)/gt;return function(f,c){if(f.pow(c,e)===f.neg(f.ONE))throw new Error("Cannot find square root");let a=r,d=f.pow(f.mul(f.ONE,o),n),u=f.pow(c,s),h=f.pow(c,n);for(;!f.eql(h,f.ONE);){if(f.eql(h,f.ZERO))return f.ZERO;let w=1;for(let b=f.sqr(h);w<a&&!f.eql(b,f.ONE);w++)b=f.sqr(b);const B=f.pow(d,q<<BigInt(a-w-1));d=f.sqr(B),u=f.mul(u,B),h=f.mul(h,d),a=w}return u}}function vr(t){if(t%ae===xr){const e=(t+q)/ae;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%Ue===Oe){const e=(t-Oe)/Ue;return function(r,o){const s=r.mul(o,gt),i=r.pow(s,e),f=r.mul(o,i),c=r.mul(r.mul(f,gt),i),a=r.mul(f,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return Br(t)}const lo=(t,e)=>(C(t,e)&q)===q,Ar=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ke(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=Ar.reduce((r,o)=>(r[o]="function",r),e);return It(t,n)}function Sr(t,e,n){if(n<R)throw new Error("invalid exponent, negatives unsupported");if(n===R)return t.ONE;if(n===q)return e;let r=t.ONE,o=e;for(;n>R;)n&q&&(r=t.mul(r,o)),o=t.sqr(o),n>>=q;return r}function _r(t,e){const n=new Array(e.length),r=e.reduce((s,i,f)=>t.is0(i)?s:(n[f]=s,t.mul(s,i)),t.ONE),o=t.inv(r);return e.reduceRight((s,i,f)=>t.is0(i)?s:(n[f]=t.mul(s,n[f]),t.mul(s,i)),o),n}function Ge(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Ye(t,e,n=!1,r={}){if(t<=R)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:s}=Ge(t,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i;const f=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:xe(o),ZERO:R,ONE:q,create:c=>C(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return R<=c&&c<t},is0:c=>c===R,isOdd:c=>(c&q)===q,neg:c=>C(-c,t),eql:(c,a)=>c===a,sqr:c=>C(c*c,t),add:(c,a)=>C(c+a,t),sub:(c,a)=>C(c-a,t),mul:(c,a)=>C(c*a,t),pow:(c,a)=>Sr(f,c,a),div:(c,a)=>C(c*ue(a,t),t),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>ue(c,t),sqrt:r.sqrt||(c=>(i||(i=vr(t)),i(f,c))),invertBatch:c=>_r(f,c),cmov:(c,a,d)=>d?a:c,toBytes:c=>n?me(c,s):ut(c,s),fromBytes:c=>{if(c.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+c.length);return n?pe(c):X(c)}});return Object.freeze(f)}function We(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Xe(t){const e=We(t);return e+Math.ceil(e/2)}function Ir(t,e,n=!1){const r=t.length,o=We(e),s=Xe(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const i=n?X(t):pe(t),f=C(i,e-q)+q;return n?me(f,o):ut(f,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const He=BigInt(0),Vt=BigInt(1);function ne(t,e){const n=e.negate();return t?n:e}function Qe(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function re(t,e){Qe(t,e);const n=Math.ceil(e/t)+1,r=2**(t-1);return{windows:n,windowSize:r}}function Lr(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((n,r)=>{if(!(n instanceof e))throw new Error("invalid point at index "+r)})}function Or(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((n,r)=>{if(!e.isValid(n))throw new Error("invalid scalar at index "+r)})}const oe=new WeakMap,Je=new WeakMap;function se(t){return Je.get(t)||1}function Ur(t,e){return{constTimeNegate:ne,hasPrecomputes(n){return se(n)!==1},unsafeLadder(n,r,o=t.ZERO){let s=n;for(;r>He;)r&Vt&&(o=o.add(s)),s=s.double(),r>>=Vt;return o},precomputeWindow(n,r){const{windows:o,windowSize:s}=re(r,e),i=[];let f=n,c=f;for(let a=0;a<o;a++){c=f,i.push(c);for(let d=1;d<s;d++)c=c.add(f),i.push(c);f=c.double()}return i},wNAF(n,r,o){const{windows:s,windowSize:i}=re(n,e);let f=t.ZERO,c=t.BASE;const a=BigInt(2**n-1),d=2**n,u=BigInt(n);for(let h=0;h<s;h++){const w=h*i;let B=Number(o&a);o>>=u,B>i&&(B-=d,o+=Vt);const b=w,l=w+Math.abs(B)-1,g=h%2!==0,y=B<0;B===0?c=c.add(ne(g,r[b])):f=f.add(ne(y,r[l]))}return{p:f,f:c}},wNAFUnsafe(n,r,o,s=t.ZERO){const{windows:i,windowSize:f}=re(n,e),c=BigInt(2**n-1),a=2**n,d=BigInt(n);for(let u=0;u<i;u++){const h=u*f;if(o===He)break;let w=Number(o&c);if(o>>=d,w>f&&(w-=a,o+=Vt),w===0)continue;let B=r[h+Math.abs(w)-1];w<0&&(B=B.negate()),s=s.add(B)}return s},getPrecomputes(n,r,o){let s=oe.get(r);return s||(s=this.precomputeWindow(r,n),n!==1&&oe.set(r,o(s))),s},wNAFCached(n,r,o){const s=se(n);return this.wNAF(s,this.getPrecomputes(s,n,o),r)},wNAFCachedUnsafe(n,r,o,s){const i=se(n);return i===1?this.unsafeLadder(n,r,s):this.wNAFUnsafe(i,this.getPrecomputes(i,n,o),r,s)},setWindowSize(n,r){Qe(r,e),Je.set(n,r),oe.delete(n)}}}function Hr(t,e,n,r){if(Lr(n,t),Or(r,e),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,s=Pe(BigInt(n.length)),i=s>12?s-3:s>4?s-2:s?2:1,f=(1<<i)-1,c=new Array(f+1).fill(o),a=Math.floor((e.BITS-1)/i)*i;let d=o;for(let u=a;u>=0;u-=i){c.fill(o);for(let w=0;w<r.length;w++){const B=r[w],b=Number(B>>BigInt(u)&BigInt(f));c[b]=c[b].add(n[w])}let h=o;for(let w=c.length-1,B=o;w>0;w--)B=B.add(c[w]),h=h.add(B);if(d=d.add(h),u!==0)for(let w=0;w<i;w++)d=d.double()}return d}function Fe(t){return Ke(t.Fp),It(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ge(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const Nr=X;function ft(t,e){if(Ht(t),Ht(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function Tr(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function Ht(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function qr(t,e,n,r){Q(t),Q(e),Ht(n),e.length>255&&(e=r(P(Xt("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:s}=r,i=Math.ceil(n/o);if(n>65535||i>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=P(e,ft(e.length,1)),c=ft(0,s),a=ft(n,2),d=new Array(i),u=r(P(c,t,a,ft(0,1),f));d[0]=r(P(u,ft(1,1),f));for(let w=1;w<=i;w++){const B=[Tr(u,d[w-1]),ft(w+1,1),f];d[w]=r(P(...B))}return P(...d).slice(0,n)}function kr(t,e,n,r,o){if(Q(t),Q(e),Ht(n),e.length>255){const s=Math.ceil(2*r/8);e=o.create({dkLen:s}).update(Xt("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(ft(n,2)).update(e).update(ft(e.length,1)).digest()}function Ne(t,e,n){It(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:i,expand:f,DST:c}=n;Q(t),Ht(e);const a=typeof c=="string"?Xt(c):c,d=r.toString(2).length,u=Math.ceil((d+o)/8),h=e*s*u;let w;if(f==="xmd")w=qr(t,a,h,i);else if(f==="xof")w=kr(t,a,h,o,i);else if(f==="_internal_pass")w=t;else throw new Error('expand must be "xmd" or "xof"');const B=new Array(e);for(let b=0;b<e;b++){const l=new Array(s);for(let g=0;g<s;g++){const y=u*(g+b*s),m=w.subarray(y,y+u);l[g]=C(Nr(m),r)}B[b]=l}return B}function Cr(t,e){const n=e.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,i,f,c]=n.map(a=>a.reduce((d,u)=>t.add(t.mul(d,r),u)));return r=t.div(s,i),o=t.mul(o,t.div(f,c)),{x:r,y:o}}}function Rr(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=Ne(r,2,{...n,DST:n.DST,...o}),i=t.fromAffine(e(s[0])),f=t.fromAffine(e(s[1])),c=i.add(f).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=Ne(r,1,{...n,DST:n.encodeDST,...o}),i=t.fromAffine(e(s[0])).clearCofactor();return i.assertValidity(),i},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const s of r)if(typeof s!="bigint")throw new Error("mapToCurve: expected array of bigints");const o=t.fromAffine(e(r)).clearCofactor();return o.assertValidity(),o}}}const Vr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),st=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),it=new Uint32Array(64);class $r extends ur{constructor(){super(64,32,8,!1),this.A=st[0]|0,this.B=st[1]|0,this.C=st[2]|0,this.D=st[3]|0,this.E=st[4]|0,this.F=st[5]|0,this.G=st[6]|0,this.H=st[7]|0}get(){const{A:e,B:n,C:r,D:o,E:s,F:i,G:f,H:c}=this;return[e,n,r,o,s,i,f,c]}set(e,n,r,o,s,i,f,c){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=f|0,this.H=c|0}process(e,n){for(let u=0;u<16;u++,n+=4)it[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const h=it[u-15],w=it[u-2],B=W(h,7)^W(h,18)^h>>>3,b=W(w,17)^W(w,19)^w>>>10;it[u]=b+it[u-7]+B+it[u-16]|0}let{A:r,B:o,C:s,D:i,E:f,F:c,G:a,H:d}=this;for(let u=0;u<64;u++){const h=W(f,6)^W(f,11)^W(f,25),w=d+h+fr(f,c,a)+Vr[u]+it[u]|0,b=(W(r,2)^W(r,13)^W(r,22))+ar(r,o,s)|0;d=a,a=c,c=f,f=i+w|0,i=s,s=o,o=r,r=w+b|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,f=f+this.E|0,c=c+this.F|0,a=a+this.G|0,d=d+this.H|0,this.set(r,o,s,i,f,c,a,d)}roundClean(){it.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const zt=ir(()=>new $r);class tn extends Ze{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,nr(e);const r=be(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=e.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(e){return Mt(this),this.iHash.update(e),this}digestInto(e){Mt(this),Gt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:f}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=i,e.outputLen=f,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const en=(t,e,n)=>new tn(t,e).update(n).digest();en.create=(t,e)=>new tn(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Te(t){t.lowS!==void 0&&vt("lowS",t.lowS),t.prehash!==void 0&&vt("prehash",t.prehash)}function Mr(t){const e=Fe(t);It(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:zr,hexToBytes:Zr}=mr,et={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(t,e)=>{const{Err:n}=et;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=Et(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?Et(o.length/2|128):"";return Et(t)+s+o+e},decode(t,e){const{Err:n}=et;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++],s=!!(o&128);let i=0;if(!s)i=o;else{const c=o&127;if(!c)throw new n("tlv.decode(long): indefinite length not supported");if(c>4)throw new n("tlv.decode(long): byte length is too big");const a=e.subarray(r,r+c);if(a.length!==c)throw new n("tlv.decode: length bytes not complete");if(a[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const d of a)i=i<<8|d;if(r+=c,i<128)throw new n("tlv.decode(long): not minimal encoding")}const f=e.subarray(r,r+i);if(f.length!==i)throw new n("tlv.decode: wrong value length");return{v:f,l:e.subarray(r+i)}}},_int:{encode(t){const{Err:e}=et;if(t<Y)throw new e("integer: negative integers are not allowed");let n=Et(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=et;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return zr(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=et,o=typeof t=="string"?Zr(t):t;Q(o);const{v:s,l:i}=r.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:f,l:c}=r.decode(2,s),{v:a,l:d}=r.decode(2,c);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(f),s:n.decode(a)}},hexFromSig(t){const{_tlv:e,_int:n}=et,r=e.encode(2,n.encode(t.r)),o=e.encode(2,n.encode(t.s)),s=r+o;return e.encode(48,s)}},Y=BigInt(0),N=BigInt(1),ct=BigInt(2),Zt=BigInt(3),qe=BigInt(4);function jr(t){const e=Mr(t),{Fp:n}=e,r=Ye(e.n,e.nBitLength),o=e.toBytes||((b,l,g)=>{const y=l.toAffine();return P(Uint8Array.from([4]),n.toBytes(y.x),n.toBytes(y.y))}),s=e.fromBytes||(b=>{const l=b.subarray(1),g=n.fromBytes(l.subarray(0,n.BYTES)),y=n.fromBytes(l.subarray(n.BYTES,2*n.BYTES));return{x:g,y}});function i(b){const{a:l,b:g}=e,y=n.sqr(b),m=n.mul(y,b);return n.add(n.add(m,n.mul(b,l)),g)}if(!n.eql(n.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function f(b){return _t(b,N,e.n)}function c(b){const{allowedPrivateKeyLengths:l,nByteLength:g,wrapPrivateKey:y,n:m}=e;if(l&&typeof b!="bigint"){if(wt(b)&&(b=At(b)),typeof b!="string"||!l.includes(b.length))throw new Error("invalid private key");b=b.padStart(g*2,"0")}let v;try{v=typeof b=="bigint"?b:X($("private key",b,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof b)}return y&&(v=C(v,m)),at("private key",v,N,m),v}function a(b){if(!(b instanceof h))throw new Error("ProjectivePoint expected")}const d=fe((b,l)=>{const{px:g,py:y,pz:m}=b;if(n.eql(m,n.ONE))return{x:g,y};const v=b.is0();l==null&&(l=v?n.ONE:n.inv(m));const O=n.mul(g,l),I=n.mul(y,l),A=n.mul(m,l);if(v)return{x:n.ZERO,y:n.ZERO};if(!n.eql(A,n.ONE))throw new Error("invZ was invalid");return{x:O,y:I}}),u=fe(b=>{if(b.is0()){if(e.allowInfinityPoint&&!n.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:l,y:g}=b.toAffine();if(!n.isValid(l)||!n.isValid(g))throw new Error("bad point: x or y not FE");const y=n.sqr(g),m=i(l);if(!n.eql(y,m))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(l,g,y){if(this.px=l,this.py=g,this.pz=y,l==null||!n.isValid(l))throw new Error("x required");if(g==null||!n.isValid(g))throw new Error("y required");if(y==null||!n.isValid(y))throw new Error("z required");Object.freeze(this)}static fromAffine(l){const{x:g,y}=l||{};if(!l||!n.isValid(g)||!n.isValid(y))throw new Error("invalid affine point");if(l instanceof h)throw new Error("projective point not allowed");const m=v=>n.eql(v,n.ZERO);return m(g)&&m(y)?h.ZERO:new h(g,y,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const g=n.invertBatch(l.map(y=>y.pz));return l.map((y,m)=>y.toAffine(g[m])).map(h.fromAffine)}static fromHex(l){const g=h.fromAffine(s($("pointHex",l)));return g.assertValidity(),g}static fromPrivateKey(l){return h.BASE.multiply(c(l))}static msm(l,g){return Hr(h,r,l,g)}_setWindowSize(l){B.setWindowSize(this,l)}assertValidity(){u(this)}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){a(l);const{px:g,py:y,pz:m}=this,{px:v,py:O,pz:I}=l,A=n.eql(n.mul(g,I),n.mul(v,m)),_=n.eql(n.mul(y,I),n.mul(O,m));return A&&_}negate(){return new h(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:g}=e,y=n.mul(g,Zt),{px:m,py:v,pz:O}=this;let I=n.ZERO,A=n.ZERO,_=n.ZERO,S=n.mul(m,m),V=n.mul(v,v),T=n.mul(O,O),H=n.mul(m,v);return H=n.add(H,H),_=n.mul(m,O),_=n.add(_,_),I=n.mul(l,_),A=n.mul(y,T),A=n.add(I,A),I=n.sub(V,A),A=n.add(V,A),A=n.mul(I,A),I=n.mul(H,I),_=n.mul(y,_),T=n.mul(l,T),H=n.sub(S,T),H=n.mul(l,H),H=n.add(H,_),_=n.add(S,S),S=n.add(_,S),S=n.add(S,T),S=n.mul(S,H),A=n.add(A,S),T=n.mul(v,O),T=n.add(T,T),S=n.mul(T,H),I=n.sub(I,S),_=n.mul(T,V),_=n.add(_,_),_=n.add(_,_),new h(I,A,_)}add(l){a(l);const{px:g,py:y,pz:m}=this,{px:v,py:O,pz:I}=l;let A=n.ZERO,_=n.ZERO,S=n.ZERO;const V=e.a,T=n.mul(e.b,Zt);let H=n.mul(g,v),j=n.mul(y,O),p=n.mul(m,I),x=n.add(g,y),E=n.add(v,O);x=n.mul(x,E),E=n.add(H,j),x=n.sub(x,E),E=n.add(g,m);let L=n.add(v,I);return E=n.mul(E,L),L=n.add(H,p),E=n.sub(E,L),L=n.add(y,m),A=n.add(O,I),L=n.mul(L,A),A=n.add(j,p),L=n.sub(L,A),S=n.mul(V,E),A=n.mul(T,p),S=n.add(A,S),A=n.sub(j,S),S=n.add(j,S),_=n.mul(A,S),j=n.add(H,H),j=n.add(j,H),p=n.mul(V,p),E=n.mul(T,E),j=n.add(j,p),p=n.sub(H,p),p=n.mul(V,p),E=n.add(E,p),H=n.mul(j,E),_=n.add(_,H),H=n.mul(L,E),A=n.mul(x,A),A=n.sub(A,H),H=n.mul(x,j),S=n.mul(L,S),S=n.add(S,H),new h(A,_,S)}subtract(l){return this.add(l.negate())}is0(){return this.equals(h.ZERO)}wNAF(l){return B.wNAFCached(this,l,h.normalizeZ)}multiplyUnsafe(l){const{endo:g,n:y}=e;at("scalar",l,Y,y);const m=h.ZERO;if(l===Y)return m;if(this.is0()||l===N)return this;if(!g||B.hasPrecomputes(this))return B.wNAFCachedUnsafe(this,l,h.normalizeZ);let{k1neg:v,k1:O,k2neg:I,k2:A}=g.splitScalar(l),_=m,S=m,V=this;for(;O>Y||A>Y;)O&N&&(_=_.add(V)),A&N&&(S=S.add(V)),V=V.double(),O>>=N,A>>=N;return v&&(_=_.negate()),I&&(S=S.negate()),S=new h(n.mul(S.px,g.beta),S.py,S.pz),_.add(S)}multiply(l){const{endo:g,n:y}=e;at("scalar",l,N,y);let m,v;if(g){const{k1neg:O,k1:I,k2neg:A,k2:_}=g.splitScalar(l);let{p:S,f:V}=this.wNAF(I),{p:T,f:H}=this.wNAF(_);S=B.constTimeNegate(O,S),T=B.constTimeNegate(A,T),T=new h(n.mul(T.px,g.beta),T.py,T.pz),m=S.add(T),v=V.add(H)}else{const{p:O,f:I}=this.wNAF(l);m=O,v=I}return h.normalizeZ([m,v])[0]}multiplyAndAddUnsafe(l,g,y){const m=h.BASE,v=(I,A)=>A===Y||A===N||!I.equals(m)?I.multiplyUnsafe(A):I.multiply(A),O=v(this,g).add(v(l,y));return O.is0()?void 0:O}toAffine(l){return d(this,l)}isTorsionFree(){const{h:l,isTorsionFree:g}=e;if(l===N)return!0;if(g)return g(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:g}=e;return l===N?this:g?g(h,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return vt("isCompressed",l),this.assertValidity(),o(h,this,l)}toHex(l=!0){return vt("isCompressed",l),At(this.toRawBytes(l))}}h.BASE=new h(e.Gx,e.Gy,n.ONE),h.ZERO=new h(n.ZERO,n.ONE,n.ZERO);const w=e.nBitLength,B=Ur(h,e.endo?Math.ceil(w/2):w);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:f}}function Pr(t){const e=Fe(t);return It(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Dr(t){const e=Pr(t),{Fp:n,n:r}=e,o=n.BYTES+1,s=2*n.BYTES+1;function i(p){return C(p,r)}function f(p){return ue(p,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:a,weierstrassEquation:d,isWithinCurveOrder:u}=jr({...e,toBytes(p,x,E){const L=x.toAffine(),U=n.toBytes(L.x),k=P;return vt("isCompressed",E),E?k(Uint8Array.from([x.hasEvenY()?2:3]),U):k(Uint8Array.from([4]),U,n.toBytes(L.y))},fromBytes(p){const x=p.length,E=p[0],L=p.subarray(1);if(x===o&&(E===2||E===3)){const U=X(L);if(!_t(U,N,n.ORDER))throw new Error("Point is not on curve");const k=d(U);let z;try{z=n.sqrt(k)}catch(K){const Z=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+Z)}const M=(z&N)===N;return(E&1)===1!==M&&(z=n.neg(z)),{x:U,y:z}}else if(x===s&&E===4){const U=n.fromBytes(L.subarray(0,n.BYTES)),k=n.fromBytes(L.subarray(n.BYTES,2*n.BYTES));return{x:U,y:k}}else{const U=o,k=s;throw new Error("invalid Point, expected length of "+U+", or uncompressed "+k+", got "+x)}}}),h=p=>At(ut(p,e.nByteLength));function w(p){const x=r>>N;return p>x}function B(p){return w(p)?i(-p):p}const b=(p,x,E)=>X(p.slice(x,E));class l{constructor(x,E,L){this.r=x,this.s=E,this.recovery=L,this.assertValidity()}static fromCompact(x){const E=e.nByteLength;return x=$("compactSignature",x,E*2),new l(b(x,0,E),b(x,E,2*E))}static fromDER(x){const{r:E,s:L}=et.toSig($("DER",x));return new l(E,L)}assertValidity(){at("r",this.r,N,r),at("s",this.s,N,r)}addRecoveryBit(x){return new l(this.r,this.s,x)}recoverPublicKey(x){const{r:E,s:L,recovery:U}=this,k=I($("msgHash",x));if(U==null||![0,1,2,3].includes(U))throw new Error("recovery id invalid");const z=U===2||U===3?E+e.n:E;if(z>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=U&1?"03":"02",J=c.fromHex(M+h(z)),K=f(z),Z=i(-k*K),bt=i(L*K),nt=c.BASE.multiplyAndAddUnsafe(J,Z,bt);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new l(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return St(this.toDERHex())}toDERHex(){return et.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return St(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const g={isValidPrivateKey(p){try{return a(p),!0}catch{return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const p=Xe(e.n);return Ir(e.randomBytes(p),e.n)},precompute(p=8,x=c.BASE){return x._setWindowSize(p),x.multiply(BigInt(3)),x}};function y(p,x=!0){return c.fromPrivateKey(p).toRawBytes(x)}function m(p){const x=wt(p),E=typeof p=="string",L=(x||E)&&p.length;return x?L===o||L===s:E?L===2*o||L===2*s:p instanceof c}function v(p,x,E=!0){if(m(p))throw new Error("first arg must be private key");if(!m(x))throw new Error("second arg must be public key");return c.fromHex(x).multiply(a(p)).toRawBytes(E)}const O=e.bits2int||function(p){if(p.length>8192)throw new Error("input is too large");const x=X(p),E=p.length*8-e.nBitLength;return E>0?x>>BigInt(E):x},I=e.bits2int_modN||function(p){return i(O(p))},A=xe(e.nBitLength);function _(p){return at("num < 2^"+e.nBitLength,p,Y,A),ut(p,e.nByteLength)}function S(p,x,E=V){if(["recovered","canonical"].some(dt=>dt in E))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:U}=e;let{lowS:k,prehash:z,extraEntropy:M}=E;k==null&&(k=!0),p=$("msgHash",p),Te(E),z&&(p=$("prehashed msgHash",L(p)));const J=I(p),K=a(x),Z=[_(K),_(J)];if(M!=null&&M!==!1){const dt=M===!0?U(n.BYTES):M;Z.push($("extraEntropy",dt))}const bt=P(...Z),nt=J;function Qt(dt){const yt=O(dt);if(!u(yt))return;const Jt=f(yt),Lt=c.BASE.multiply(yt).toAffine(),ht=i(Lt.x);if(ht===Y)return;const Ot=i(Jt*i(nt+ht*K));if(Ot===Y)return;let Ut=(Lt.x===ht?0:2)|Number(Lt.y&N),pt=Ot;return k&&w(Ot)&&(pt=B(Ot),Ut^=1),new l(ht,pt,Ut)}return{seed:bt,k2sig:Qt}}const V={lowS:e.lowS,prehash:!1},T={lowS:e.lowS,prehash:!1};function H(p,x,E=V){const{seed:L,k2sig:U}=S(p,x,E),k=e;return De(k.hash.outputLen,k.nByteLength,k.hmac)(L,U)}c.BASE._setWindowSize(8);function j(p,x,E,L=T){var Ut;const U=p;x=$("msgHash",x),E=$("publicKey",E);const{lowS:k,prehash:z,format:M}=L;if(Te(L),"strict"in L)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const J=typeof U=="string"||wt(U),K=!J&&!M&&typeof U=="object"&&U!==null&&typeof U.r=="bigint"&&typeof U.s=="bigint";if(!J&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let Z,bt;try{if(K&&(Z=new l(U.r,U.s)),J){try{M!=="compact"&&(Z=l.fromDER(U))}catch(pt){if(!(pt instanceof et.Err))throw pt}!Z&&M!=="der"&&(Z=l.fromCompact(U))}bt=c.fromHex(E)}catch{return!1}if(!Z||k&&Z.hasHighS())return!1;z&&(x=e.hash(x));const{r:nt,s:Qt}=Z,dt=I(x),yt=f(Qt),Jt=i(dt*yt),Lt=i(nt*yt),ht=(Ut=c.BASE.multiplyAndAddUnsafe(bt,Jt,Lt))==null?void 0:Ut.toAffine();return ht?i(ht.x)===nt:!1}return{CURVE:e,getPublicKey:y,getSharedSecret:v,sign:H,verify:j,ProjectivePoint:c,Signature:l,utils:g}}function Kr(t,e){const n=t.ORDER;let r=Y;for(let B=n-N;B%ct===Y;B/=ct)r+=N;const o=r,s=ct<<o-N-N,i=s*ct,f=(n-N)/i,c=(f-N)/ct,a=i-N,d=s,u=t.pow(e,f),h=t.pow(e,(f+N)/ct);let w=(B,b)=>{let l=u,g=t.pow(b,a),y=t.sqr(g);y=t.mul(y,b);let m=t.mul(B,y);m=t.pow(m,c),m=t.mul(m,g),g=t.mul(m,b),y=t.mul(m,B);let v=t.mul(y,g);m=t.pow(v,d);let O=t.eql(m,t.ONE);g=t.mul(y,h),m=t.mul(v,l),y=t.cmov(g,y,O),v=t.cmov(m,v,O);for(let I=o;I>N;I--){let A=I-ct;A=ct<<A-N;let _=t.pow(v,A);const S=t.eql(_,t.ONE);g=t.mul(y,l),l=t.mul(l,l),_=t.mul(v,l),y=t.cmov(g,y,S),v=t.cmov(_,v,S)}return{isValid:O,value:y}};if(t.ORDER%qe===Zt){const B=(t.ORDER-Zt)/qe,b=t.sqrt(t.neg(e));w=(l,g)=>{let y=t.sqr(g);const m=t.mul(l,g);y=t.mul(y,m);let v=t.pow(y,B);v=t.mul(v,m);const O=t.mul(v,b),I=t.mul(t.sqr(v),g),A=t.eql(I,l);let _=t.cmov(O,v,A);return{isValid:A,value:_}}}return w}function Gr(t,e){if(Ke(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=Kr(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,i,f,c,a,d,u;o=t.sqr(r),o=t.mul(o,e.Z),s=t.sqr(o),s=t.add(s,o),i=t.add(s,t.ONE),i=t.mul(i,e.B),f=t.cmov(e.Z,t.neg(s),!t.eql(s,t.ZERO)),f=t.mul(f,e.A),s=t.sqr(i),a=t.sqr(f),c=t.mul(a,e.A),s=t.add(s,c),s=t.mul(s,i),a=t.mul(a,f),c=t.mul(a,e.B),s=t.add(s,c),d=t.mul(o,i);const{isValid:h,value:w}=n(s,a);u=t.mul(o,r),u=t.mul(u,w),d=t.cmov(d,i,h),u=t.cmov(u,w,h);const B=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,B),d=t.div(d,f),{x:d,y:u}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Yr(t){return{hash:t,hmac:(e,...n)=>en(t,e,sr(...n)),randomBytes:je}}function Wr(t,e){const n=r=>Dr({...t,...Yr(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),jt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Nt=BigInt(1),Pt=BigInt(2),ke=(t,e)=>(t+e/Pt)/e;function nn(t){const e=kt,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),f=BigInt(44),c=BigInt(88),a=t*t*t%e,d=a*a*t%e,u=D(d,n,e)*d%e,h=D(u,n,e)*d%e,w=D(h,Pt,e)*a%e,B=D(w,o,e)*w%e,b=D(B,s,e)*B%e,l=D(b,f,e)*b%e,g=D(l,c,e)*l%e,y=D(g,f,e)*b%e,m=D(y,n,e)*d%e,v=D(m,i,e)*B%e,O=D(v,r,e)*a%e,I=D(O,Pt,e);if(!lt.eql(lt.sqr(I),t))throw new Error("Cannot find square root");return I}const lt=Ye(kt,void 0,void 0,{sqrt:nn}),Ct=Wr({a:BigInt(0),b:BigInt(7),Fp:lt,n:jt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=jt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Nt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,i=BigInt("0x100000000000000000000000000000000"),f=ke(s*t,e),c=ke(-r*t,e);let a=C(t-f*n-c*o,e),d=C(-f*r-c*s,e);const u=a>i,h=d>i;if(u&&(a=e-a),h&&(d=e-d),a>i||d>i)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:h,k2:d}}}},zt),rn=BigInt(0),Ce={};function Dt(t,...e){let n=Ce[t];if(n===void 0){const r=zt(Uint8Array.from(t,o=>o.charCodeAt(0)));n=P(r,r),Ce[t]=n}return zt(P(n,...e))}const Ee=t=>t.toRawBytes(!0).slice(1),le=t=>ut(t,32),ie=t=>C(t,kt),Tt=t=>C(t,jt),Be=Ct.ProjectivePoint,Xr=(t,e,n)=>Be.BASE.multiplyAndAddUnsafe(t,e,n);function de(t){let e=Ct.utils.normPrivateKeyToScalar(t),n=Be.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:Tt(-e),bytes:Ee(n)}}function on(t){at("x",t,Nt,kt);const e=ie(t*t),n=ie(e*t+BigInt(7));let r=nn(n);r%Pt!==rn&&(r=ie(-r));const o=new Be(t,r,Nt);return o.assertValidity(),o}const Bt=X;function sn(...t){return Tt(Bt(Dt("BIP0340/challenge",...t)))}function Qr(t){return de(t).bytes}function Jr(t,e,n=je(32)){const r=$("message",t),{bytes:o,scalar:s}=de(e),i=$("auxRand",n,32),f=le(s^Bt(Dt("BIP0340/aux",i))),c=Dt("BIP0340/nonce",f,o,r),a=Tt(Bt(c));if(a===rn)throw new Error("sign failed: k is zero");const{bytes:d,scalar:u}=de(a),h=sn(d,o,r),w=new Uint8Array(64);if(w.set(d,0),w.set(le(Tt(u+h*s)),32),!cn(w,r,o))throw new Error("sign: Invalid signature produced");return w}function cn(t,e,n){const r=$("signature",t,64),o=$("message",e),s=$("publicKey",n,32);try{const i=on(Bt(s)),f=Bt(r.subarray(0,32));if(!_t(f,Nt,kt))return!1;const c=Bt(r.subarray(32,64));if(!_t(c,Nt,jt))return!1;const a=sn(le(f),Ee(i),o),d=Xr(i,c,Tt(-a));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}const Fr={getPublicKey:Qr,sign:Jr,verify:cn,utils:{randomPrivateKey:Ct.utils.randomPrivateKey,lift_x:on,pointToBytes:Ee,numberToBytesBE:ut,bytesToNumberBE:X,taggedHash:Dt,mod:C}},to=Cr(lt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))),eo=Gr(lt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:lt.create(BigInt("-11"))}),fn=Rr(Ct.ProjectivePoint,t=>{const{x:e,y:n}=eo(lt.create(t[0]));return to(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:lt.ORDER,m:1,k:128,expand:"xmd",hash:zt}),no=fn.hashToCurve,ro=fn.encodeToCurve,go=Object.freeze(Object.defineProperty({__proto__:null,encodeToCurve:ro,hashToCurve:no,schnorr:Fr,secp256k1:Ct},Symbol.toStringTag,{value:"Module"}));export{vn as $,Fe as A,It as B,Hr as C,at as D,$ as E,Ye as F,pe as G,Me as H,me as I,At as J,Ur as K,P as L,fe as M,je as N,D as O,lo as P,hn as Q,Re as R,bn as S,un as T,_n as U,Vn as V,Cn as W,$n as X,Rn as Y,An as Z,wn as _,Kt as a,Wr as a0,zt as a1,pn as b,En as c,$t as d,Fn as e,uo as f,io as g,mn as h,go as i,oo as j,Ae as k,Xn as l,C as m,co as n,xn as o,Bn as p,ve as q,Sn as r,Ct as s,qt as t,$e as u,gn as v,ge as w,ir as x,ur as y,vt as z};
